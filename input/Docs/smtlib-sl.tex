\documentclass[10pt]{llncs}

\usepackage[usenames,dvipsnames]{color}


\usepackage{fancybox}
\usepackage{latexsym}
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{paralist}
\usepackage{txfonts}
\usepackage{framed}
\usepackage{makecell}
\usepackage{url}
\usepackage{hyperref}

\usepackage{proof}

\usepackage{fancyvrb}
\fvset{fontsize=\small}
\usepackage{color}

%\usepackage[draft]{commenting}
\usepackage[final]{commenting}

\pagestyle{plain}

\include{commands}

\definecolor{darkgreen}{rgb}{0,0.6,0}
\declareauthor{ri}{Radu}{blue}
\declareauthor{ar}{Andy}{red}
\declareauthor{cs}{Cristina}{darkgreen}
\declareauthor{ms}{Mihaela}{magenta}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sloppy
\title{Encoding Separation Logic in SMT-LIB v2.5}

\author{Radu Iosif\inst{2} \and Cristina Serban\inst{2} \and Andrew Reynolds\inst{1} \and Mihaela Sighireanu\inst{3}} 

\institute{The University of Iowa \and Verimag/CNRS/Universit\'e de Grenoble Alpes \and IRIF/Universit\'e Paris Diderot}

\maketitle

\begin{abstract}
  We propose an encoding of Separation Logic using SMT-LIB v2.5. This
  format is currently supported by SMT solvers (CVC4) and inductive
  proof-theoretic solvers (SLIDE and SPEN). Moreover, we provide a
  library of benchmarks written using this format, which stems from
  the set of benchmarks used in SL-COMP'14 \cite{sl-comp14}.
\end{abstract}

\section{Preliminaries}

We consider formulae in multi-sorted first-order logic.  A
\emph{signature} $\Sigma$ consists of a set $\ssorts{\Sigma}$ of sort
symbols and a set $\sfuns{\Sigma}$ of \emph{function symbols}
$f^{\sigma_1 \cdots \sigma_n \sigma}$, where $n \geq 0$ and $\sigma_1,
\ldots, \sigma_n, \sigma \in \ssorts{\Sigma}$. If $n=0$, we call
$f^\sigma$ a \emph{constant symbol}. We make the following
assumptions:
\begin{compactenum}
\item all signatures $\Sigma$ contain the Boolean sort $\bool$, where
  $\top$ and $\bot$ denote the Boolean constants \emph{true} and
  \emph{false}. 
\item $\sfuns{\Sigma}$ contains a boolean equality function
  $\teq^{\sigma\sigma\bool}$ for each sort symbol
  $\sigma\in\ssorts{\Sigma}$.
\end{compactenum}

Let $\vars$ be a countable set of first-order variables, each
$x^\sigma \in \vars$ having an associated sort $\sigma$. First-order
terms and formulae over the signature $\Sigma$ (called $\Sigma$-terms
and $\Sigma$-formulae) are defined as usual. A first-order variable is
\emph{free} if it does not occur within the scope of a quantifier, and
we write $\varphi(\vec{x})$ to denote that the free variables of the
formula $\varphi$ belong to the set $\vec{x}$. 

A \emph{$\Sigma$-interpretation $\I$} maps:\begin{compactitem}
\item each sort symbol $\sigma \in \Sigma$ to a non-empty set $\sigma^\I$,
\item each function symbol $f^{\sigma_1,\ldots,\sigma_n,\sigma} \in \Sigma$ to a
  total function $f^\I : \sigma^\I_1 \times \ldots \times \sigma^\I_n
  \rightarrow \sigma^\I$ where $n > 0$, and to an element of $\sigma^\I$ when $n
  = 0$, and
\item each variable $x^\sigma \in \vars$ to an element of $\sigma^\I$.
\end{compactitem}

For an interpretation $\I$ a sort symbol $\sigma$ and a variable $x$,
we denote by $\I[\sigma \leftarrow S]$ and, respectively $\I[x
  \leftarrow v]$, the interpretation associating the set $S$ to
$\sigma$, respectively the value $v$ to $x$, and which behaves like
$\I$ in all other cases. By writing $\I[\sigma \leftarrow S]$ we
ensure that all variables of sort $\sigma$ are mapped by $\I$ to
elements of $S$. For a $\Sigma$-term $t$, we write $t^\I$ to denote
the interpretation of $t$ in $\I$, defined inductively, as usual. A
satisfiability relation between $\Sigma$-interpretations and
$\Sigma$-formulas, written $\I \models \varphi$, is also defined
inductively, as usual. In this case, we say that $\I$ is a
\emph{model} of $\varphi$. 

A (multi-sorted first-order) \emph{theory} is a pair \(T = (\Sigma,
\mods)\) where $\Sigma$ is a signature and $\mods$ is a non-empty set
of $\Sigma$-interpretations, the \emph{models} of $T$. A
$\Sigma$-formula $\varphi$ is \emph{$T$-satisfiable} if it is
satisfied by some interpretation in $\mods$.

\section{Ground Separation Logic}
\label{sec:gsl}

Let \(T = (\Sigma, \mods)\) be a theory and let $\locs$ and $\data$ be
two sorts from $\Sigma$, with no restriction other than the fact that
$\locs$ is always interpreted as a countable set. Also, we consider
that $\Sigma$ has a designated constant symbol $\nil^\locs$. We define
the \emph{Ground Separation Logic} $\seplog(T)^g_{\locs,\data}$ to
be the set of formulae generated by the following syntax:
\[\begin{array}{lcl}
\varphi & := & \phi \mid \emp \mid \tterm \mapsto \uterm \mid
\varphi_1 * \varphi_2 \mid \varphi_1 \wand \varphi_2 \mid \neg
\varphi_1 \mid \varphi_1 \wedge \varphi_2 \mid \exists x^\sigma ~.~
\varphi_1(x)
\end{array}\]
where $\phi$ is a $\Sigma$-formula, and $\tterm$, $\uterm$ are
$\Sigma$-terms of sorts $\locs$ and $\data$, respectively. As usual,
we write $\forall x^\sigma ~.~ \varphi(x)$ for $\neg\exists x^\sigma
~.~ \neg\varphi(x)$. We omit specifying the sorts of variables and
functions when they are clear from the context.

Given an interpretation $\I$, a \emph{heap} is a finite partial
mapping $h : \locs^\I \rightharpoonup_{\mathrm{fin}} \data^\I$. For a
heap $h$, we denote by $\dom(h)$ its domain. For two heaps $h_1$ and
$h_2$, we write $h_1 \# h_2$ for $\dom(h_1) \cap \dom(h_2) =
\emptyset$ and $h = h_1 \uplus h_2$ for $h_1 \# h_2$ and $h = h_1 \cup
h_2$. We define the \emph{satisfaction relation} $\I,h
\models_{\tinyseplog} \phi$ inductively, as follows:
\[\begin{array}{lcl}
\I,h \models_{\tinyseplog} \phi & \iff & \I \models \phi \text{ if $\phi$ is a $\Sigma$-formula} \\
\I,h \models_{\tinyseplog} \emp & \iff & h = \emptyset \\
\I,h \models_{\tinyseplog} \tterm \mapsto \uterm & \iff & 
h = \{(\tterm^\I,\uterm^\I)\} \text{ and } \tterm^\I\not\teq\nil^\I \\
\I,h \models_{\tinyseplog} \phi_1 * \phi_2 & \iff & \text{there exist heaps } h_1,h_2 
\text{ s.t. } h=h_1\uplus h_2 
\text{ and } \I,h_i \models_{\tinyseplog} \phi_i, i = 1,2 \\
\I,h \models_{\tinyseplog} \phi_1 \wand \phi_2 & \iff & \text{for all heaps } h' \text{ if } h'\#h 
\text{ and } \I,h' \models_{\tinyseplog} \phi_1
\text{ then } \I,h'\uplus h \models_{\tinyseplog} \phi_2 \\
\I,h \models_{\tinyseplog} \exists x^S . \varphi(x) & \iff & 
\I[x \leftarrow s],h \models_{\tinyseplog} \varphi(x) \text{, for some }s \in S^\I
\end{array}\]
The satisfaction relation for $\Sigma$-formulae, Boolean connectives
$\wedge$, $\neg$, and linear arithmetic atoms, are the classical ones
from first-order logic. Notice that the range of a quantified variable
$x^S$ is the interpretation of its associated sort $S^\I$. A formula
$\varphi$ is said to be \emph{satisfiable} if there exists an
interpretation $\I$ and a heap $h$ such that $\I,h
\models_{\tinyseplog} \varphi$. We say that $\varphi$ \emph{entails}
$\psi$, written $\varphi \models_{\tinyseplog} \psi$, when every pair
$(\I,h)$ which satisfies $\varphi$, also satisfies $\psi$.

\subsection{SMT-LIB Encoding}

We write ground $\seplog$ formulae in SMT-LIB using the following functions: 
\begin{center}
\shadowbox{
\begin{minipage}{7cm}
%(emp Bool)  %% needed to extend at typed theory
\begin{Verbatim}
(par (Loc Data) (emp Loc Data Bool))
(sep Bool Bool Bool :left-assoc)
(wand Bool Bool Bool :right-assoc)
(par (Loc Data) (pto Loc Data Bool))
(par (Loc) (nil Loc))
\end{Verbatim}
\end{minipage}}
\end{center}
\changed[ms]{Observe that {\tt emp},} 
%Observe that
{\tt pto} and {\tt nil} are polymorphic functions, with
sort parameters {\tt Loc} and {\tt Data}. There is no restriction on
the choice of {\tt Loc} and {\tt Data}, as shown below. 
\changed[ms]{However, in addition to the classical SMT-LIB typing constraints, 
the $\seplog$ theories require that the heap models are well-typed. 

The type of heap models is fixed using a special command,
not included in SMT-LIB, {\tt declare-heap}.
For example,} assume that {\tt Loc} is an uninterpreted sort $\mathsf{U}$ and 
{\tt Data} is the integer sort $\Int$. The following declarations
fix the type of the heap model and some constant names:
\begin{Verbatim}
(declare-sort U 0)

(declare-heap (U Int))

(declare-const x U)
(declare-const y U)
(declare-const a Int)
(declare-const b Int)
\end{Verbatim}
We write the $\seplog$ formula \(\emp \wedge ((x \mapsto a * y \mapsto
b) \wand (x \mapsto \nil * \top))\) in SMT-LIB as follows:
\begin{Verbatim}
(and (as emp U Int) 
     (wand (sep (pto x a) (pto y b)) (sep (pto x (as nil Int)) true))
)
\end{Verbatim}
With the declarations above, a separation constraint of the form: 
\begin{Verbatim}
(sep (pto x y) (pto a b))
\end{Verbatim}
results in a typing error, because {\tt (pto x y)} requires 
the heap to be of type $\mathsf{U} \rightharpoonup \mathsf{U}$, 
whereas {\tt (pto a b)} requires the heap
to be of type $\Int \rightharpoonup \Int$, and combining heaps of
different types is not allowed. 

%\todo{
%  \begin{compactenum} 
%    \item It is currently unclear what the type of the heap introduced by
%  {\tt emp} should be. The solution currently adopted in CVC4 is to
%  give {\tt emp} parameters used only to infer the type, as in {\tt
%    (emp x a)}. Another solution, used in SLIDE, is to infer the type
%  of {\tt emp} based on the context. For instance the type of the {\tt
%    emp} heap in {\tt (sep (pto x a) emp)} is $\mathsf{U}
%  \rightharpoonup \Int$. We leave this point for discussion. 
%  %
%  \item It is usually expected that {\tt nil} be of type $\locs$,
%    however currently one can force other type that $\locs$, like in
%    the previous example. Shall we impose a stricter type checking on
%    {\tt nil} ?
%  \end{compactenum}
%}

This heap typing restriction is not a limitation of the expressive
power of the SMT-LIB encoding and can be easily overcome by using
datatypes (available in SMT-LIB v2.5). Suppose, for instance that we
would like to specify a heap consisting of cells containing both
integer and boolean data. The idea is to declare a union type: 
\begin{Verbatim}
(declare-datatype BoolInt ((cons_bool (d Bool)) (cons_int (d Int))))

(declare-heap (U BoolInt))
\end{Verbatim}
and use it to describe a mixed data heap, as in: 
\begin{Verbatim}
(sep (pto x (cons_bool false)) (pto y (cons_int 0)))
\end{Verbatim}
%The same workaround can be used to specify heaps with mixed addresses,
%although this is a much less common situation in practice. 
\changed[ms]{The extension of the heap typing with typed locations is presented in Section~\ref{sec:tsl}.}


\subsection{Separation Logic with Inductive Definitions}

Let $\preds$ be a set of second-order variables, each $P^{\sigma_1
  \ldots \sigma_n} \in \preds$ having an associated tuple of parameter
sorts $\sigma_1, \ldots, \sigma_n \in \ssorts{\Sigma}$. In addition to
the first-order terms built using variables from $\vars$ and function
symbols from $\sfuns{\Sigma}$, we enrich the language of $\seplog$
with the boolean terms $P^{\sigma_1 \ldots \sigma_n}(t_1, \ldots,
t_n)$, where each $t_i$ is a first-order term of sort $\sigma_i$, for
$i=1,\ldots,n$. Each second-order variable $P^{\sigma_1 \ldots
  \sigma_n} \in \preds$ is provided with an inductive definition
$P(x_1,\ldots,x_n) \leftarrow \phi_P(x_1,\ldots,x_n)$, where $\phi_P$
is a formula in the extended language, possibly containing occurrences
of $P$. The satisfaction relation is then extended as follows:
\[\I,h \models_{\tinyseplog} P^{\sigma_1 \ldots \sigma_n}(t_1,\ldots,t_n) \iff 
\I,h \models_{\tinyseplog} \phi_P(t^\I_1,\ldots,t^I_n)\] where
$\phi_P$ is the inductive definition of $P^{\sigma_1 \ldots
  \sigma_n}$. Observe that, given a set of inductive definitions, the
set of possible models for each second-order variable is the least
fixed point of a monotonic and continuous function mapping tuples of
sets of models to a set of models.

\subsection{SMT-LIB Encoding}

An inductive definition $P(x_1,\ldots,x_n) \leftarrow
\phi_P(x_1,\ldots,x_n)$ is written in SMT-LIB using a recursive
function definition. For instance, the inductive definition of a 
doubly-linked list segment:
\[\begin{array}{rcl}
\mathsf{dllseg}(h, p, t, n) & \leftarrow & (\emp \wedge h \teq n \wedge p \teq t) ~\vee \\
&& (\exists x^{\locs} ~.~ h \mapsto (x,p) * \mathsf{dllseg}(x,h,t,n))
\end{array}\]
is written into SMT-LIB as follows: 
\begin{Verbatim}
(declare-datatype Node ((node (next Loc) (prev Loc))))

(declare-heap (Loc Node))

(define-fun-rec dllseg ((h Loc) (p Loc) (t Loc) (n Loc)) Bool
    (or (and emp (= h n) (= p t))
        (exists ((x Loc)) (sep (pto h (node x p)) (dllseg x h t n)))
    )
)
\end{Verbatim}

\subsection{A Detailed Example} 

Let us go through an example step by step. First of all, the preamble
of and SMT-LIB file describing a $\seplog$ satisfiability query must
contain (at least): 
\begin{Verbatim}
(set-logic SEPLOG)
\end{Verbatim}
\changed[ms]{The fragments of this theory are defined in Section~\ref{sec:frag}.}
If $\seplog$ is used in combination with other theories, it is
customary to start with:
\begin{Verbatim}
(set-logic ALL_SUPPORTED)
\end{Verbatim}
We consider the slightly modified version of the $\mathsf{dllseg}$
definition above, which describes a doubly-linked list segment with
ordered integer data: 
\[\begin{array}{rcl}
\mathsf{dllseg}_{\mathit{ord}}(h, p, t, n, min) & \leftarrow & (\emp \wedge h \teq n \wedge p \teq t) ~\vee \\
&& (\exists x^{\locs} \exists d^{\Int} ~.~ h \mapsto (d,x,min) * \mathsf{dllseg}_{\mathit{ord}}(x,h,t,n,d)) \wedge min \leq d
\end{array}\]
Since we do not perform any pointer arithmetic reasoning, we can
declare $\locs$ to be an uninterpreted sort: 
\begin{Verbatim}
(declare-sort Loc 0)
\end{Verbatim}
\changed[ms]{We encode the definition of $\mathsf{dllseg}_{\mathit{ord}}$ as:} 
\begin{Verbatim}
(declare-datatype Node ((node (data Int) (next Loc) (prev Loc))))

(declare-heap (Loc Node))

(define-fun-rec dllseg_ord ((h Loc) (p Loc) (t Loc) (n Loc) (min Int)) Bool
    (or (and (as emp Loc Data) (= h n) (= p t))
        (exists ((x Loc) (d Int)) 
                (and 
                     (sep (pto h (node x p)) (dllseg_ord x h t n)) 
                     (<= min d)
                )
        )
    )
)
\end{Verbatim}
Let us consider the problem of proving that a
$\mathsf{dllseg}_{\mathit{ord}}$ to which a node is appended is again
a $\mathsf{dllseg}_{\mathit{ord}}$, provided that the data of the new
node it smaller than the minimal element of the first
$\mathsf{dllseg}_{\mathit{ord}}$:
\[x \mapsto (m,u,v) * \mathsf{dllseg}_{\mathit{ord}}(u,x,z,t,n) \wedge m \leq n
\models_{\tinyseplog} \mathsf{dllseg}_{\mathit{ord}}(x,y,z,t,m)\]
We encode this entailment problem as an assertion asking whether the negated problem is satisfiable:  
\begin{Verbatim}
(declare-const x U)
(declare-const y U)
(declare-const z U)
(declare-const u U)
(declare-const v U)
(declare-const t U)
(declare-const m Int)
(declare-const n Int)

(assert (not (implies 
              (and (sep (pto x (node m u v)) (dllseg_ord u x z t n)) (<= m n)) 
              (dllseg_ord x y z t m)
             )
        )
)
\end{Verbatim}
The entailment holds when the assertion is unsatisfiable, which can be
checked in the standard way, using 
{\tt (check-sat)}.
However, the dual problem:
\begin{Verbatim}
(assert (not (implies 
              (dllseg_ord x y z t m)
              (and (sep (pto x (node m u v)) (dllseg_ord u x z t n)) (<= m n)) 
)       )    )
\end{Verbatim}
is satisfiable, and the counter-model can be obtained in the standard
way, using {\tt (get-model)}. Observe that the model of a satisfiable
$\seplog$ query consists of an interpretation of the constants and a
specification of the heap. 

\changed[ms]{To comply with the format of SL-COMP'14 \cite{sl-comp14}, the entailment
problems may also be encoded using two separate assertions:}
\begin{Verbatim}
(assert (dllseg_ord x y z t m))
(assert (not (and (sep (pto x (node m u v)) (dllseg_ord u x z t n)) (<= m n))
)       )
(check-sat)
\end{Verbatim}



\section{Multi-Sorted Separation Logic}
\label{sec:tsl}

\changed[ms]{Until now, we considered only problems with one type of locations.}
However, the heap typing declaration allows to declare a union type
by listing the pair of types for locations and the corresponding 
heap cells.

For example, consider a heap storing a nested list.
Locations in the inner lists are typed by {\tt RefList} and 
the heap cells at these locations, typed by {\tt List}, 
are linked by one field:
\begin{Verbatim}
(declare-sort RefList 0)
(declare-datatype List ((c_list (next RefList))))
\end{Verbatim}
The heap cells of the upper list are typed by {\tt Nll} and 
store a pair of locations, one of type {\tt RefList} to the inner list,
and a location of a same type of cell, typed by {\tt RefNll}:
\begin{Verbatim}
(declare-sort RefNll 0)
(declare-datatype Nll ((c_nll (next RefNll) (down RefList))))

(declare-heap (RefNll Nll) (RefList List))
\end{Verbatim}
A heap containing two cell is specified by:
\begin{Verbatim}
(declare-const x RefNll)
(declare-const y RefList)

(assert (sep (pto x (c_nll (as nil RefNll) y))
             (pto z (c_list (as nil RefList)))
             (_ emp RefList List))
)
\end{Verbatim}
The empty heap is typed by one of the pairs of the union type declared
for the heap.



\section{Abduction and Frame Inference}

Abduction and frame inference (or bi-abduction for both) are problems
that occur in the context of program verification. In this case, the
solver is not only required to give a yes/no answer to a
satisfiability query, but to infer $\seplog$ formulae that ensure the
validity of a given entailment. Given $\seplog$ formulae
$\varphi(\vec{x})$ and $\phi(\vec{y})$, and second-order variables
$X(\vec{x},\vec{y})$ and $Y(\vec{x},\vec{y})$, we consider the
following synthesis problems:

\begin{compactenum}
\item The \emph{abduction problem} asks for a satisfiable definition
  of a $X$ such that $\varphi(\vec{x}) * X(\vec{x},\vec{y})
  \models_{\tinyseplog} \psi(\vec{y})$. Sometimes $X$ is called an
  \emph{anti-frame}. Observe that $X \leftarrow \bot$ is always a
  solution, but not a very interesting one.
%
\item The \emph{frame inference problem} asks for a definition of $Y$
  such that $\varphi(\vec{x}) \models_{\tinyseplog} \exists \vec{z}
  ~.~ \psi(\vec{y}) * Y(\vec{x},\vec{y})$, where $\vec{z} = \vec{y}
  \setminus \vec{x}$.
%
\item The \emph{bi-abduction problem} asks for both a satisfiable
  definition of $X$ and a definition of $Y$ such that
  $\varphi(\vec{x}) * X(\vec{x},\vec{y}) \models_{\tinyseplog}
  \psi(\vec{y}) * Y(\vec{x},\vec{y})$.
\end{compactenum}
The capability of solving the above problems is key to using a given
$\seplog$ solver for practical program verification purposes. For this
reason, we aim at finding a standard way of specifying these problems
in SMT-LIB.


\section{Logics}
\label{sec:frag}

\changed[ms]{The benchmarks of SL-COMP refer to one of the sub-logics of the 
many-sorted Separation Logic.}  
These sub-logics identify fragments of
the main logic for which have been identified efficient techniques 
for checking satisfiability and entailment.

The sub-logics are named using groups of letters, in a similar way 
that SMT-LIB. These letters have been chosen to evoke the restrictions 
used by the sub-logics:
\begin{compactitem}
\item {\tt QF} for the restriction to quantifier free formulas;
\item {\tt SH} for the symbolic heap fragment where formulas are conjunction of atoms and don't constraints $\phi$ and magic wand;
\item {\tt LS} where the only inductively defined predicate is the acyclic list segment, {\tt ls};
\item {\tt BI} for the fragment with magic wand atoms;
\item {\tt ID} for the fragment with user defined predicates.
\end{compactitem} 
%%\todo{Other logics:
%% L : linear inductive definitions, like in the previous division FDP
%% interpreted predicate atoms list and tree like in GRASShoper
%% 

\medskip
The following logics are used in the SL-COMP benchmark:
\begin{compactitem}
\item {\tt QF\_SHLS} is the logic for the divisions 
{\tt sll0a\_sat} and {\tt sll0a\_entl} of SL-COMP'14. A formula in these scripts is 
a conjunction of pure and spatial atoms except magic wand  and including
list segment predicate atoms.


\item {\tt QF\_SHID} is the logic for the divisions
{\tt UDP\_sat}, {\tt UDP\_entl}, {\tt FDP\_sat} and {\tt FDP\_entl} of SL-COMP'14. 
The scripts include inductive definitions of predicates and
formulas that are conjunctions of aliasing, points-to and predicate atoms.


\item {\tt QF\_BI} corresponds mainly to the logic defined in 
CVC4 \cite{cvc4-seplog}, where formulas are quantifier free and
boolean combinations of pure and spatial including magic wand;
the scripts do not include inductive definitions and the heap
type is only one pair of location and data sorts.

\end{compactitem} 




\section{Additional Resources}

The quest for a suitable format for $\seplog$ solvers started with
SL-COMP'14 \cite{sl-comp14}, which adopted the {\tt QF\_S} format,
described in \cite{qfs}. The current proposal is inspired by {\tt
  QF\_S}, and relies on the datatypes introduced SMT-LIB v2.5 for an
elegant treatment of union and record types. The tools supporting
SMT-LIB as a native language are: \begin{compactitem}
\item CVC4 \cite{ReynoldsIosifKingSerban16} -- a description of the $\seplog$
  format of CVC4 is provided in \cite{cvc4-seplog} (a slightly
  modified version of the current proposal)
\item SLIDE (under construction) -- uses the encoding from the current
  proposal.
\item SPEN \cite{spen} -- a description of the $\seplog$
  format of SPEN ({\tt QF\_S}) is available in \cite{qfs}.
\end{compactitem} 
Other tools that participated to SL-COMP'14 have been adapted to {\tt
  QF\_S} by means of a specialized front-end \cite{qfs-frontend}. It
is our goal to convince the developers of $\seplog$ solvers to adopt
SMT-LIB as the native input language of their tools, rather than use a
translator from SMT-LIB. For this purpose, we provide a C++ front-end
\cite{smtlib-frontend} that can be used to parse and type check
$\seplog$ inputs encoded in SMT-LIB using the current specification. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain} 
\bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
